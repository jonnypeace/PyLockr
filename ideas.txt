from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import base64

def encrypt_data(data, dek_b64):
    # Decode the DEK from Base64
    dek = base64.b64decode(dek_b64)
    aesgcm = AESGCM(dek)
    # For AESGCM, an IV should be 12 bytes long and unique for each encryption
    iv = AESGCM.generate_iv(12)
    # Encrypt the data. AESGCM requires bytes, so ensure `data` is bytes
    encrypted_data = aesgcm.encrypt(iv, data.encode(), None)
    # Return the IV and encrypted data, both encoded in Base64 for storage or transmission
    return base64.b64encode(iv), base64.b64encode(encrypted_data)

def decrypt_data(encrypted_data_b64, iv_b64, dek_b64):
    # Decode the IV, encrypted data, and DEK from Base64
    iv = base64.b64decode(iv_b64)
    encrypted_data = base64.b64decode(encrypted_data_b64)
    dek = base64.b64decode(dek_b64)
    aesgcm = AESGCM(dek)
    # Decrypt the data
    data = aesgcm.decrypt(iv, encrypted_data, None)
    # Return the decrypted data as a string
    return data.decode()

# Encrypt data
iv_b64, encrypted_data_b64 = encrypt_data("Hello, world!", dek_b64)

# Decrypt data
decrypted_data = decrypt_data(encrypted_data_b64, iv_b64, dek_b64)
print(decrypted_data)  # Output: "Hello, world!"


###################################

from flask import Flask, jsonify, request, session
import os

app = Flask(__name__)
app.secret_key = 'your_secret_key_here'  # Needed for session management

@app.route('/get_salt', methods=['POST'])
def get_salt():
    # Authentication check (ensure the user is logged in or is in the process of signing up)
    username = request.json.get('username')
    if not username:
        return jsonify({'error': 'Missing username'}), 400

    # Here, you'd typically look up the user in your database to get their unique salt
    # For new signups, you'd generate a new salt
    salt = os.urandom(16)  # Generate a new 16-byte salt for demonstration
    salt_b64 = base64.b64encode(salt).decode('utf-8')  # Encode as Base64 for easy transmission

    # Optionally, save the generated salt in the database associated with the user

    return jsonify({'salt': salt_b64})

if __name__ == '__main__':
    app.run(debug=True)


async function fetchSalt(username) {
    try {
        const response = await fetch('/get_salt', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('input[name="csrf_token"]').value // Assuming you have a CSRF token input in your form
            },
            body: JSON.stringify({username: username})
        });

        if (!response.ok) {
            throw new Error('Failed to fetch salt');
        }

        const data = await response.json();
        return data.salt; // The Base64 encoded salt
    } catch (error) {
        console.error('Error fetching salt:', error);
        throw error;
    }
}

// Example usage:
const username = 'user@example.com'; // This would be dynamically set based on user input
fetchSalt(username).then(salt => {
    console.log('Salt fetched:', salt);
    // Proceed with using the salt for further operations, like password hashing
}).catch(error => {
    // Handle any errors, such as displaying a message to the user
});
